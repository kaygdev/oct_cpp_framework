#include "treestructbin.h"
#include "cvmattreestruct.h"

#include <cassert>

#include <fstream>
#include <string>

#include <opencv/cv.h>

#include <boost/lexical_cast.hpp>

namespace CppFW
{

	namespace
	{
		const uint32_t version = 1;
		const char     magic[] = "CVMatBin";


		template<typename T>
		inline void writeBin2Stream(std::ostream* stream, const T& value, std::size_t num = 1)
		{
			stream->write(reinterpret_cast<const char*>(&value), sizeof(T)*num);
		}
		
		template<typename T>
		inline void readBinStream(std::istream* stream, T& value, std::size_t num = 1)
		{
			stream->read(reinterpret_cast<char*>(&value), sizeof(T)*num);
		}
		

		template<typename T>
		inline void writeMatBin(std::ostream* stream, const cv::Mat& mat)
		{
			int channels = mat.channels();
			for(int i = 0; i < mat.rows; i++)
			{
				const T* mi = mat.ptr<T>(i);
				for(int j = 0; j < mat.cols; j++)
				{
					for(int c = 0; c < channels; ++c)
					{
						writeBin2Stream(stream, *mi);
						++mi;
					}
				}
			}
		}
	}


	bool CVMatTreeStructBin::writeBin(const std::string& filename, const CVMatTree& tree)
	{
		std::ofstream stream(filename, std::ios::binary | std::ios::out);
		if(!stream.good())
			return false;
		
		return writeBin(stream, tree);
	}
	
	
	
	bool CVMatTreeStructBin::writeBin(std::ostream& stream, const CVMatTree& tree)
	{
		CVMatTreeStructBin writer(stream);
		writer.writeHeader();
		writer.handleNodeWrite(tree);

		return true;
	}



	void CVMatTreeStructBin::writeDir(const CVMatTree& node)
	{
		const CVMatTree::NodeDir& nodes = node.getNodeDir();

		writeBin2Stream<uint32_t>(ostream, static_cast<uint32_t>(nodes.size()));
		for(const CVMatTree::NodePair& pair : nodes)
		{
			const std::string& name  = pair.first;
			const CVMatTree* subNode = pair.second;

			writeBin2Stream(ostream, name);
			handleNodeWrite(*subNode);
		}
	}


	void CVMatTreeStructBin::writeList(const CVMatTree& node)
	{
		const CVMatTree::NodeList& nodes = node.getNodeList();

		writeBin2Stream<uint32_t>(ostream, static_cast<uint32_t>(nodes.size()));
		for(const CVMatTree* subNode : nodes)
		{
			handleNodeWrite(*subNode);
		}
	}


	void CVMatTreeStructBin::handleNodeWrite(const CVMatTree& node)
	{
		writeBin2Stream<uint32_t>(ostream, static_cast<uint32_t>(node.type()));
		switch(node.type())
		{
			case CVMatTree::Type::Undef:
				break;
			case CVMatTree::Type::Dir:
				writeDir(node);
				break;
			case CVMatTree::Type::List:
				writeList(node);
				break;
			case CVMatTree::Type::Mat:
				writeMatP(node.getMat());
				break;
		}
	}
	
	bool CVMatTreeStructBin::handleNodeRead(CVMatTree& node)
	{
		assert(node.type() == CVMatTree::Type::Undef);
		
		uint32_t type;
		writeBin2Stream<uint32_t>(ostream, type);
		switch(static_cast<CVMatTree::Type>(type))
		{
			case CVMatTree::Type::Undef:
				return true;
			case CVMatTree::Type::Dir:
				return readDir(node);
			case CVMatTree::Type::List:
				return readList(node);
			case CVMatTree::Type::Mat:
				return readMatP(node.getMat());
		}
		return false;
	}



	void CVMatTreeStructBin::writeHeader()
	{
		ostream->write(magic, sizeof(magic)-1);
		writeBin2Stream<uint32_t>(ostream, version);

		writeBin2Stream<uint32_t>(ostream, 0);
		writeBin2Stream<uint32_t>(ostream, 0);
		writeBin2Stream<uint32_t>(ostream, 0);
		writeBin2Stream<uint32_t>(ostream, 0);
	}
	
	bool CVMatTreeStructBin::readHeader()
	{
		char readmagic[sizeof(magic)-1];
		istream->read(readmagic, sizeof(magic)-1);
		if(std::memcmp(magic, readmagic, sizeof(magic)-1) != 0)
			return false;
		uint32_t readedVersion;
		writeBin2Stream<uint32_t>(ostream, readedVersion);
		if(version != readedVersion)
			return false;
		
		uint32_t tmp;
		readBinStream<uint32_t>(istream, tmp);
		readBinStream<uint32_t>(istream, tmp);
		readBinStream<uint32_t>(istream, tmp);
		readBinStream<uint32_t>(istream, tmp);
		return true;
	}


	void CVMatTreeStructBin::writeMatP(const cv::Mat& mat)
	{
		writeBin2Stream<uint32_t>(ostream, mat.type());
		writeBin2Stream<uint32_t>(ostream, mat.channels());

		writeBin2Stream<uint32_t>(ostream, mat.rows);
		writeBin2Stream<uint32_t>(ostream, mat.cols);

		writeBin2Stream<uint32_t>(ostream, 0);
		writeBin2Stream<uint32_t>(ostream, 0);
		writeBin2Stream<uint32_t>(ostream, 0);
		writeBin2Stream<uint32_t>(ostream, 0);

	#define HandleType(X) case cv::DataType<X>::type: writeMatBin<X>(ostream, mat); break;
		switch(mat.type())
		{
			HandleType(uint8_t)
			HandleType(uint16_t)
			HandleType(uint32_t)
			HandleType(int8_t)
			HandleType(int16_t)
			HandleType(int32_t)
			HandleType(float)
			HandleType(double)
			default:
				std::cerr << "writeMatP: Unhandled Mat-Type";
		}
	#undef HandleType
	}


	void CVMatTreeStructBin::writeMatlabReadCode(const char* filename)
	{
		const char* help = "% [Mats] = readbin(filename)\n\
% read a bin file writen by C++ class WriteCVMat2Bin\n\
% Input  : a bin file\n% Output : a cellarray with the read matrics\n\n\
% this file is generated by WriteCVMat2Bin::writeMatlabCode\n";


		std::ofstream stream(filename, std::ios::out);

		std::string matlabCode;

		stream << "function [ Mats, Names ] = readbin(filename)\n";
		stream << help;
		stream << "\tfileID = fopen(filename);\n";
		stream << "\tif fileID == -1\n";
		stream << "\t	error(['cant open file ' filename]);\n";
		stream << "\tend\n";

		stream << "\tmagic    = fread(fileID, " << boost::lexical_cast<std::string>(sizeof(magic)-1) << ", 'char');\n";
		stream << "\tmagicstr = sprintf('%s', magic);\n";
		stream << std::string("\tif strcmp(magicstr, '") << magic << "') == false\n";
		stream << "\t	error('not a bin file')\n";
		stream << "\tend\n";
		stream << "\tversion  = fread(fileID, 1, 'uint32');\n";
		stream << "\tassert(version == 0);\n";
		stream << "\tnumMats  = fread(fileID, 1, 'uint32');\n";
		stream << "\t           fread(fileID, 4, 'uint32');\n";

		stream << "\tMats  = {};\n";
		stream << "\tNames = {};\n";
		stream << "\tfor i = 1:numMats\n";
		stream << "\t\t[Mat, name] = readMat(fileID);\n";
		stream << "\t\tMats {length(Mats )+1} = Mat;\n";
		stream << "\t\tNames{length(Names)+1} = name;\n";
		stream << "\tend\n";

		stream << "\tfclose(fileID);\nend\n\n\n";


		stream << "function [mat, name] = readMat(fileID)\n";
		stream << "\tname = '';\n";
		stream << "\ttype     = fread(fileID, 1, 'uint32');\n";
		stream << "\tchannels = fread(fileID, 1, 'uint32');\n";
		stream << "\trows     = fread(fileID, 1, 'uint32');\n";
		stream << "\tcols     = fread(fileID, 1, 'uint32');\n";
		stream << "\t           fread(fileID, 4, 'uint32');\n";

	#define MatlabSwtichType(X, Y) 	stream << "		case " << boost::lexical_cast<std::string>(cv::DataType<X>::type) << " % OpenCV type for "#X"\n\t\tmat = fread(fileID, [cols rows], '"#Y"')';\n";
		stream << "	switch type\n";
		MatlabSwtichType(uint8_t , uint8 )
		MatlabSwtichType(uint16_t, uint16)
		MatlabSwtichType(uint32_t, uint32)
		MatlabSwtichType( int8_t , int8  )
		MatlabSwtichType( int16_t, int16 )
		MatlabSwtichType( int32_t, int32 )
		MatlabSwtichType( float  , single)
		MatlabSwtichType( double , double)

		stream << "\tend\n";
		stream << "end\n";
	}



}
