#include "treestructbin.h"
#include "cvmattreestruct.h"

#include <fstream>
#include <string>

#include <opencv/cv.h>

#include <boost/lexical_cast.hpp>

namespace CppFW
{

	namespace
	{
		const uint32_t version = 1;
		const char     magic[] = "CVMatBin";


		template<typename T>
		inline void writeBin2Stream(std::ostream& stream, const T& value, std::size_t num = 1)
		{
			stream.write(reinterpret_cast<const char*>(&value), sizeof(T)*num);
		}

		template<typename T>
		inline void writeMatBin(std::ostream& stream, const cv::Mat& mat)
		{
			int channels = mat.channels();
			for(int i = 0; i < mat.rows; i++)
			{
				const T* mi = mat.ptr<T>(i);
				for(int j = 0; j < mat.cols; j++)
				{
					for(int c = 0; c < channels; ++c)
					{
						writeBin2Stream(stream, *mi);
						++mi;
					}
				}
			}
		}
	}


	bool CVMatTreeStructBin::writeBin(const std::string& filename, const CVMatTree& tree)
	{
		stream.open(filename, std::ios::binary | std::ios::out);
		if(!stream.good())
			return false;

		writeHeader();
		handleNode(tree);

		return true;
	}


	void CVMatTreeStructBin::writeDir(const CVMatTree& node)
	{
		const CVMatTree::NodeDir& nodes = node.getNodeDir();

		writeBin2Stream<uint32_t>(stream, static_cast<uint32_t>(nodes.size()));
		for(const CVMatTree::NodePair& pair : nodes)
		{
			const std::string& name  = pair.first;
			const CVMatTree* subNode = pair.second;

			writeBin2Stream(stream, name);
			handleNode(*subNode);
		}
	}


	void CVMatTreeStructBin::writeList(const CVMatTree& node)
	{
		const CVMatTree::NodeList& nodes = node.getNodeList();

		writeBin2Stream<uint32_t>(stream, static_cast<uint32_t>(nodes.size()));
		for(const CVMatTree* subNode : nodes)
		{
			handleNode(*subNode);
		}
	}


	void CVMatTreeStructBin::handleNode(const CVMatTree& node)
	{
		writeBin2Stream<uint32_t>(stream, static_cast<uint32_t>(node.type()));
		switch(node.type())
		{
			case CVMatTree::Type::Undef:
				break;
			case CVMatTree::Type::Dir:
				writeDir(node);
				break;
			case CVMatTree::Type::List:
				writeList(node);
				break;
			case CVMatTree::Type::Mat:
				writeMatP(node.getMat());
				break;
		}
	}


	void CVMatTreeStructBin::writeHeader()
	{
		stream.write(magic, sizeof(magic)-1);
		writeBin2Stream<uint32_t>(stream, version);

		writeBin2Stream<uint32_t>(stream, 0);
		writeBin2Stream<uint32_t>(stream, 0);
		writeBin2Stream<uint32_t>(stream, 0);
		writeBin2Stream<uint32_t>(stream, 0);

	}

	void CVMatTreeStructBin::writeMatP(const cv::Mat& mat)
	{
		writeBin2Stream<uint32_t>(stream, mat.type());
		writeBin2Stream<uint32_t>(stream, mat.channels());

		writeBin2Stream<uint32_t>(stream, mat.rows);
		writeBin2Stream<uint32_t>(stream, mat.cols);

		writeBin2Stream<uint32_t>(stream, 0);
		writeBin2Stream<uint32_t>(stream, 0);
		writeBin2Stream<uint32_t>(stream, 0);
		writeBin2Stream<uint32_t>(stream, 0);

	#define HandleType(X) case cv::DataType<X>::type: writeMatBin<X>(stream, mat); break;
		switch(mat.type())
		{
			HandleType(uint8_t)
			HandleType(uint16_t)
			HandleType(uint32_t)
			HandleType(int8_t)
			HandleType(int16_t)
			HandleType(int32_t)
			HandleType(float)
			HandleType(double)
			default:
				std::cerr << "writeMatP: Unhandled Mat-Type";
		}
	#undef HandleType
	}


	void CVMatTreeStructBin::writeMatlabReadCode(const char* filename)
	{
		const char* help = "% [Mats] = readbin(filename)\n\
% read a bin file writen by C++ class WriteCVMat2Bin\n\
% Input  : a bin file\n% Output : a cellarray with the read matrics\n\n\
% this file is generated by WriteCVMat2Bin::writeMatlabCode\n";


		std::ofstream stream(filename, std::ios::out);

		std::string matlabCode;

		stream << "function [ Mats, Names ] = readbin(filename)\n";
		stream << help;
		stream << "\tfileID = fopen(filename);\n";
		stream << "\tif fileID == -1\n";
		stream << "\t	error(['cant open file ' filename]);\n";
		stream << "\tend\n";

		stream << "\tmagic    = fread(fileID, " << boost::lexical_cast<std::string>(sizeof(magic)-1) << ", 'char');\n";
		stream << "\tmagicstr = sprintf('%s', magic);\n";
		stream << std::string("\tif strcmp(magicstr, '") << magic << "') == false\n";
		stream << "\t	error('not a bin file')\n";
		stream << "\tend\n";
		stream << "\tversion  = fread(fileID, 1, 'uint32');\n";
		stream << "\tassert(version == 0);\n";
		stream << "\tnumMats  = fread(fileID, 1, 'uint32');\n";
		stream << "\t           fread(fileID, 4, 'uint32');\n";

		stream << "\tMats  = {};\n";
		stream << "\tNames = {};\n";
		stream << "\tfor i = 1:numMats\n";
		stream << "\t\t[Mat, name] = readMat(fileID);\n";
		stream << "\t\tMats {length(Mats )+1} = Mat;\n";
		stream << "\t\tNames{length(Names)+1} = name;\n";
		stream << "\tend\n";

		stream << "\tfclose(fileID);\nend\n\n\n";


		stream << "function [mat, name] = readMat(fileID)\n";
		stream << "\tname = '';\n";
		stream << "\ttype     = fread(fileID, 1, 'uint32');\n";
		stream << "\tchannels = fread(fileID, 1, 'uint32');\n";
		stream << "\trows     = fread(fileID, 1, 'uint32');\n";
		stream << "\tcols     = fread(fileID, 1, 'uint32');\n";
		stream << "\t           fread(fileID, 4, 'uint32');\n";

	#define MatlabSwtichType(X, Y) 	stream << "		case " << boost::lexical_cast<std::string>(cv::DataType<X>::type) << " % OpenCV type for "#X"\n\t\tmat = fread(fileID, [cols rows], '"#Y"')';\n";
		stream << "	switch type\n";
		MatlabSwtichType(uint8_t , uint8 )
		MatlabSwtichType(uint16_t, uint16)
		MatlabSwtichType(uint32_t, uint32)
		MatlabSwtichType( int8_t , int8  )
		MatlabSwtichType( int16_t, int16 )
		MatlabSwtichType( int32_t, int32 )
		MatlabSwtichType( float  , single)
		MatlabSwtichType( double , double)

		stream << "\tend\n";
		stream << "end\n";
	}



}
